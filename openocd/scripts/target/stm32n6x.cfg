# script for stm32n6x family

#
# stm32n6 devices support both JTAG and SWD transports.
#
source [find target/swj-dp.tcl]
source [find mem_helper.tcl]
source [find gdb_helper.tcl]

if { [info exists CHIPNAME] } {
	set _CHIPNAME $CHIPNAME
} else {
	set _CHIPNAME stm32n6
}

if { [info exists CONNECT_UNDER_RESET] } {
	set _CONNECT_UNDER_RESET $CONNECT_UNDER_RESET
} else {
	set _CONNECT_UNDER_RESET 0
}

if { [info exists ENABLE_LOW_POWER] } {
	set _ENABLE_LOW_POWER $ENABLE_LOW_POWER
} else {
	set _ENABLE_LOW_POWER 0
}

if { [info exists STOP_WATCHDOG] } {
	set _STOP_WATCHDOG $STOP_WATCHDOG
} else {
	set _STOP_WATCHDOG 0
}

set _ENDIAN little

# Work-area is a space in RAM used for flash programming
# By default use 64kB
if { [info exists WORKAREASIZE] } {
	set _WORKAREASIZE $WORKAREASIZE
} else {
	set _WORKAREASIZE 0x10000
}

#jtag scan chain
if { [info exists CPUTAPID] } {
	set _CPUTAPID $CPUTAPID
} else {
   if { [using_jtag] } {
	set _CPUTAPID 0x6ba00477
	} {
	set _CPUTAPID 0x6ba02477
	}
}

swj_newdap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID
set _TARGETNAME $_CHIPNAME.cpu

dap create $_CHIPNAME.dap -chain-position $_TARGETNAME

target create $_CHIPNAME.ap0 mem_ap -endian $_ENDIAN -dap $_CHIPNAME.dap -ap-num 0

target create $_TARGETNAME cortex_m -endian $_ENDIAN -dap $_CHIPNAME.dap -ap-num 1 -gdb-max-connections 2

# use secure RAM by default
$_TARGETNAME configure -work-area-phys 0x34000000 -work-area-size $_WORKAREASIZE -work-area-backup 1

if { ![using_hla] } {
	swo  create $_CHIPNAME.swo  -dap $_CHIPNAME.dap -ap-num 1 -baseaddr 0xE008A000
	tpiu create $_CHIPNAME.tpiu -dap $_CHIPNAME.dap -ap-num 1 -baseaddr 0xE0084000
}

if { [info exists FLASH_LOADERS] } {
	foreach FLASH_LOADER $FLASH_LOADERS {
		flash bank $FLASH_LOADER stldr 0 0 0 0 [target current] $FLASH_LOADER
	}
}

if { [info exists CLOCK_FREQ] } {
	set _CLOCK_FREQ $CLOCK_FREQ
} else {
	set _CLOCK_FREQ 4000
}
adapter speed $_CLOCK_FREQ

adapter srst delay 100
if {[using_jtag]} {
	jtag_ntrst_delay 100
}

if { ![using_hla] } {
	# if srst is not fitted use SYSRESETREQ to
	# perform a soft reset
	cortex_m reset_config sysresetreq
}

proc stm32n6x_is_secure {} {
	# read Debug Security Control and Status Regsiter (DSCSR) and check CDS (bit 16)
	set DSCSR [mrw 0xE000EE08]
	set secure [expr {($DSCSR & (1 << 16)) != 0}]
	return $secure
}

proc stm32n6x_ahb_ap_non_secure_access {} {
	# SPROT=1=Non Secure access, Priv=1
	[[target current] cget -dap] apcsw 0x4B000000 0x4F000000
}

proc stm32n6x_ahb_ap_secure_access {} {
	# SPROT=0=Secure access, Priv=1
	[[target current] cget -dap] apcsw 0x0B000000 0x4F000000
}

# get _CHIPNAME from current target
proc stm32n6x_get_chipname {} {
	set t [target current]
	set sep [string last "." $t]
	if {$sep == -1} {
		return $t
	}
	return [string range $t 0 [expr {$sep - 1}]]
}

# like mrw, but with target selection
proc stm32n6x_mrw {used_target reg} {
	return [$used_target read_memory $reg 32 1]
}

# like mmw, but with target selection
proc stm32n6x_mmw {used_target reg setbits clearbits} {
	set old [stm32n6x_mrw $used_target $reg]
	set new [expr {($old & ~$clearbits) | $setbits}]
	$used_target mww $reg $new
}

proc stm32n6x_enter_debug {} {

	set _CHIPNAME [stm32n6x_get_chipname]

	# check security status
	set secure [stm32n6x_is_secure]

	if {$secure} {
		stm32n6x_ahb_ap_secure_access
	} else {
		stm32n6x_ahb_ap_non_secure_access
	}

	# print the secure state only when it changes
	global $_CHIPNAME.secure
	set initialized [info exists $_CHIPNAME.secure]

	if {!$initialized || $secure != [set $_CHIPNAME.secure]} {
		# update saved security state
		set $_CHIPNAME.secure $secure

		set secure_str [expr {$secure ? "Secure" : "Non-Secure"}]
		echo "$_CHIPNAME.cpu in $secure_str state"
	}

	# use secure workarea only when TrustZone is enabled
	set use_secure_workarea 1

	set workarea_addr [$_CHIPNAME.cpu cget -work-area-phys]

	if {$use_secure_workarea} {
		set workarea_addr [expr {$workarea_addr | 0x10000000}]
	} else {
		set workarea_addr [expr {$workarea_addr & ~0x10000000}]
	}

	set workarea_addr_str [format "0x%08X" $workarea_addr]
#	echo "$_CHIPNAME.cpu work-area address is set to $workarea_addr_str"
	$_CHIPNAME.cpu configure -work-area-phys $workarea_addr

	global $_CHIPNAME.workarea_size
	if {![info exists $_CHIPNAME.workarea_size]} {
		set $_CHIPNAME.workarea_size [$_CHIPNAME.cpu cget -work-area-size]
	}

	set workarea_size [set $_CHIPNAME.workarea_size]
#	echo "$_CHIPNAME.cpu work-area is enabled"

	$_CHIPNAME.cpu configure -work-area-size $workarea_size
}

$_TARGETNAME configure -event reset-init {
global _CLOCK_FREQ

	adapter speed $_CLOCK_FREQ
}

$_CHIPNAME.ap0 configure -event examine-end {
	set _CHIPNAME [stm32n6x_get_chipname]
	# Enable Trace Port and DBG Clock (uses more power)
	# DBGMCU_CR |= DBGCLK_EN | TRACECLK_EN
	stm32n6x_mmw $_CHIPNAME.ap0 0x44001004 0x00300000 0
}

$_TARGETNAME configure -event reset-end {
	global FLASH_LOADERS
	global NAME_INITIALIZED_LOADER
	global INDEX_INITIALIZED_LOADER

	if { [info exists INDEX_INITIALIZED_LOADER] } {
		set NAME_INITIALIZED_LOADER [lindex $FLASH_LOADERS $INDEX_INITIALIZED_LOADER]
		set flash_list [flash list]
		for {set i 0} {$i < [llength $flash_list]} {incr i} {
			if { [lindex [lindex $flash_list  $i] 1] == $NAME_INITIALIZED_LOADER } {
				set INIT_BANK_ID $i
				break
			}
		}
		if { ![info exists INIT_BANK_ID] } {
			echo "ERROR: can't find bank_id for stldr init"
		} else {
			stldr init $INIT_BANK_ID
		}
	}
}

$_TARGETNAME configure -event examine-end {
global _ENABLE_LOW_POWER
global _STOP_WATCHDOG
global _CONNECT_UNDER_RESET

	stm32n6x_enter_debug
	set _CHIPNAME [stm32n6x_get_chipname]

	if { $_ENABLE_LOW_POWER == 1 } {
		# Enable debug during low power modes (uses more power)
		# DBGMCU_CR |= DBG_STANDBY | DBG_STOP | DBG_SLEEP
		stm32n6x_mmw $_CHIPNAME.ap0 0x44001004 0x00000007 0
	} else {
		# Disable debug during low power modes
		# DBGMCU_CR |= ~(DBG_STANDBY | DBG_STOP| DBG_SLEEP)
		stm32n6x_mmw $_CHIPNAME.ap0 0x44001004 0 0x00000007
	}
	if { $_STOP_WATCHDOG == 1 } {
		# Stop watchdog counters during halt
		# DBGMCU_APB1LFZ |= DBG_WWDG_STOP
		stm32n6x_mmw $_CHIPNAME.ap0 0x44001010 0x00000800 0
		# DBGMCU_APB4FZ |= DBG_IWDG_STOP
		stm32n6x_mmw $_CHIPNAME.ap0 0x4400101C 0x00040000 0
	} else {
		# Don't stop watchdog counters during halt
		# DBGMCU_APB1LFZ |= ~(DBG_WWDG_STOP)
		stm32n6x_mmw $_CHIPNAME.ap0 0x44001010 0 0x00000800
		# DBGMCU_APB4FZ |= ~(DBG_IWDG_STOP)
		stm32n6x_mmw $_CHIPNAME.ap0 0x4400101C 0 0x00040000
	}

	# needed if hardware reset mode selected
	if { $_CONNECT_UNDER_RESET == 0 } {
		halt
	}
}

$_TARGETNAME configure -event halted {
	stm32n6x_enter_debug
}

proc first_gdb_attach_hook {} {
global _CONNECT_UNDER_RESET

	# Needed to be able to use the connect_assert_srst in reset_config
	# otherwise, wrong value when reading device flash size register
	if { $_CONNECT_UNDER_RESET == 1 } {
		reset init
	}
}

$_TARGETNAME configure -event gdb-attach { gdb_attach_hook }
$_TARGETNAME configure -event gdb-detach { gdb_detach_hook }
